/**
 * @brief 全点対最短距離を求める。負の閉路の検出も可能。
 * @attention 負閉路がある場合、[0][0]=-1となる。
 * @tparam T グラフの辺の重みの型
 * @param graph グラフ本体
 * @return vector<vector<T>> 全点対最短距離を2次元配列で表現したもの。
 */
template<typename T>
vector<vector<T>> WarshallFloyd(const Graph<T> &graph){
    int V = graph.vertex.size();
    const T INF = numeric_limits<T>::max();
    vector<vector<T>> result(V, vector<T>(V, INF));
    for(int i = 0; i < V; ++i) result[i][i] = 0;
    for(auto &e : graph.edges) result[e.from][e.to] = e.cost;
    
    for(int k = 0; k < V; ++k){
        for(int i = 0; i < V; ++i){
            for(int j = 0; j < V; ++j){
                if(result[i][k] == INF || result[k][j] == INF) continue;
                result[i][j] = min(result[i][j], result[i][k] + result[k][j]);
            }
        }
    }

    bool negative = false;
    for(int i = 0; i < V; ++i) negative |= (result[i][i] < 0);
    if(negative) result[0][0] = -1;

    return result;
}