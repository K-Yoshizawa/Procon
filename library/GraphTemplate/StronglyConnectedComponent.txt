/**
 * @brief 強連結成分分解を行う。
 * 
 * @tparam T 有向グラフの型
 */
template<typename T>
struct StronglyConnectedComponent{
    public:
    Graph<T> &g;
    Graph<T> rg;
    int V;
    vector<int> topological_order, component_size;

    private:
    vector<int> order;
    vector<bool> visited;

    void dfs(int v){
        visited[v] = true;
        for(auto &e : g.vertex[v]){
            if(!visited[e.to]) dfs(e.to);
        }
        order.push_back(v);
    }

    void rdfs(int v, int k){
        visited[v] = true;
        topological_order[v] = k;
        ++component_size[k];
        for(auto &e : rg.vertex[v]){
            if(!visited[e.to]) rdfs(e.to, k);
        }
    }

    public:
    StronglyConnectedComponent(Graph<T> &g) : g(g), V(g.vertex.size()){
        rg = Graph<T>(V);
        for(auto &e : g.edges){
            rg.d_add(e.to, e.from);
        }
        visited.resize(V, false);
        topological_order.resize(V);
        component_size.resize(V, 0);
    }

    /**
     * @brief 強連結成分分解の処理を実行する。
     * @return topological_order 頂点iの所属する強連結成分のトポロジカル順序
     * @return component_size トポロジカル順序iの強連結成分の頂点数
     */
    void build(){
        for(int v = 0; v < V; ++v){
            if(!visited[v]) dfs(v);
        }
        visited.assign(V, false);
        int k = 0;
        for(int i = order.size() - 1; i >= 0; --i){
            if(!visited[order[i]]) rdfs(order[i], k++);
        }
    }

    /**
     * @brief 2頂点が同じ強連結成分に属するかを判定する
     */
    bool same(int u, int v){
        return topological_order[u] == topological_order[v];
    }
};