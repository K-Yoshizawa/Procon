/**
 * @brief  木DPをやるための補助道具みたいな
 * @note   
 * @retval None
 */
template<typename T>
struct TreeDPHelper{
    private:
    Graph<T> &g;
    int sz, tg;
    vector<int> vis, depth, index;
    vector<vector<int>> child;

    void dfs(int v, int d){
        vis[v] = 1;
        depth[v] = d;
        for(auto &e : g.vertex[v]){
            int u = e.to;
            if(vis[u]) continue;
            child[v].emplace_back(u);
            dfs(u, d + 1);
        }
        if(child[v].size() == 0) leaf.emplace_back(v);
    }

    public:
    vector<int> leaf;

    /**
     * @brief  木DP補助道具のコンストラクタ
     * @note   渡されるグラフは木であることを想定している。
     * @attention グラフが木でない場合の動作は未定義
     * @param  &g: グラフ（木）
     */
    TreeDPHelper(Graph<T> &g) : g(g), sz(g.vertex.size()), tg(0){
        vis.resize(sz, 0);
        child.resize(sz);
        depth.resize(sz);
        index.resize(sz);
        iota(index.begin(), index.end(), 0);
    }

    void build(){
        dfs(0, 0);
        sort(index.begin(), index.end(), [&](int a, int b){return depth[a] > depth[b];});
    }

    /**
     * @brief  次に見るべき頂点が存在するか
     * @note   queueでBFSするときのwhile(!que.empty())みたいな感じで使います（論理逆なので注意）
     * @retval 存在するならtrue
     */
    inline bool exist(){
        return tg != sz;
    }

    /**
     * @brief  次に見るべき頂点番号の取得
     * @note   queueのfrontみたいな感じで使います
     * @retval 次に見るべき頂点番号
     */
    inline int next(){
        return index[tg++];
    }

    /**
     * @brief  見ている頂点番号の子の取得
     * @param  v: 見ている頂点番号
     * @retval その頂点の子の頂点リスト
     */
    inline vector<int> get(int v){
        return child[v];
    }
};