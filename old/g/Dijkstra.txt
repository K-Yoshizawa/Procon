/**
 * @brief ダイクストラ法を用いて最短距離を求める。
 * 
 * @tparam T グラフの辺の重みの型
 */
template<typename T>
struct Dijkstra{
    private:
    Graph<T> &graph;
    int V;
    T INF;
    
    public:
    vector<T> dist;
    vector<int> prev_vertex, prev_edge;

    Dijkstra(Graph<T> &graph) : graph(graph), V(graph.vertex.size()){
        INF = numeric_limits<T>::max();
        dist.resize(V, INF);
        prev_vertex.resize(V, -1);
        prev_edge.resize(V, -1);
    }

    /**
     * @brief 始点sから各頂点への最短距離を求める。
     * @param s 始点
     */
    void build(int s){
        auto &g = graph.vertex;
        dist.assign(V, INF);
        dist[s] = 0;
        
        using P = pair<T, int>;
        priority_queue<P, vector<P>, greater<P>> que;
        que.emplace(0, s);
        while(!que.empty()){
            P p = que.top(); que.pop();
            T d = p.first; int v = p.second;
            if(dist[v] < d) continue;
            for(auto &e : g[v]){
                if(dist[e.to] > dist[v] + e.cost){
                    dist[e.to] = dist[v] + e.cost;
                    prev_vertex[e.to] = v;
                    prev_edge[e.to] = e.edge_idx;
                    que.emplace(dist[e.to], e.to);
                }
            }
        }
    }

    /**
     * @brief  頂点vへの距離がINFかを判定する
     * @param  v: 調べる頂点
     * @retval INFならtrue
     */
    bool inf(int v){
        return dist[v] == INF;
    }
};