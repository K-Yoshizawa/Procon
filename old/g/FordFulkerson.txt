/**
 * @brief 最大流を計算量O(FE)で求める。ただしFは最大フローである。
 */
template<typename T = int>
struct FordFulkerson{
    private:
    int V, E;
    Graph<T> &G;
    vector<vector<Edge<T>>> Gv;
    vector<Edge<T>> Ge;
    vector<int> rev;
    vector<bool> used;    

    T dfs(int s, int t, T flow){
        if(s == t) return flow;
        used[s] = true;
        for(int i = 0; i < Gv[s].size(); ++i){
            if(Gv[s][i].cost == 0) continue;
            if(used[Gv[s][i].to]) continue;
            T tflow = dfs(Gv[s][i].to, t, min(flow, Gv[s][i].cost));
            if(tflow > 0){
                Gv[s][i].cost -= tflow;
                Gv[Gv[s][i].to][Gv[s][i].vertex_ridx].cost += tflow;
                Ge[Gv[s][i].edge_idx].cost -= tflow;
                Ge[rev[Gv[s][i].edge_idx]].cost += tflow;
                return tflow;
            }
        }
        return 0;
    }

    public:
    FordFulkerson(Graph<T> &g) : G(g), V(g.vertex.size()), E(g.edges.size()){
        rev = G.add_reverse();
        Gv = G.vertex;
        Ge = G.edges;
        used.resize(V, false);
    }

    /**
     * @brief  始点sから終点tまでの最大フローを求める。
     * @note   0-index
     * @param  s: 始点の頂点番号
     * @param  t: 終点の頂点番号
     * @retval 最大フロー
     */
    T build(int s, int t){
        T ret = 0;
        while(true){
            for(int i = 0; i < V; ++i) used[i] = false;
            T f = dfs(s, t, numeric_limits<T>::max());
            if(f == 0) break;
            ret += f;
        }
        return ret;
    }
};