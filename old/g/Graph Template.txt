/**
 * @brief グラフ辺テンプレート。直接使うことは少ない気がする。
 * 
 * @tparam T 重みの型
 */
template<typename T = int>
struct Edge{
    int from, to;                           // 始点、終点
    T cost;                                 // 重み
    int edge_idx, vertex_idx, vertex_ridx;  // 辺集合でのインデックス、頂点集合でのインデックス、逆辺の頂点集合でのインデックス

    Edge() = default;

    /**
     * @brief  単純な辺の追加。あまり使わないかも？
     * @note   
     * @param  to: 終点
     * @param  cost: 辺の重み
     * @param  edge_idx: 省略可、辺集合でのインデックス
     */
    Edge(int to, T cost = 1, int edge_idx = -1) : from(-1), to(to), cost(cost), edge_idx(edge_idx) {}

    /**
     * @brief  辺の追加。主に使うのはこっち。
     * @note   
     * @param  from: 始点
     * @param  to: 終点
     * @param  cost: 辺の重み
     * @param  edge_idx: 省略可、辺集合でのインデックス
     * @param  vertex_idx: 省略可、頂点集合でのインデックス
     * @param  vertex_ridx: 省略可、逆辺の頂点集合でのインデックス
     */
    Edge(int from, int to, T cost, int edge_idx = -1, int vertex_idx = -1, int vertex_ridx = -1) : 
        from(from), to(to), cost(cost), edge_idx(edge_idx), vertex_idx(vertex_idx), vertex_ridx(vertex_ridx) {}

    bool operator<(const Edge<T> &e) const { return cost < e.cost; }
};

/**
 * @brief グラフ本体。頂点集合と辺集合の2つを保持している。
 * 
 * @tparam T グラフ辺の重みの型
 */
template<typename T = int>
struct Graph{
    vector<vector<Edge<T>>> vertex; // 頂点集合
    vector<Edge<T>> edges;          // 辺集合

    Graph(int V) : vertex(V) {}
    Graph() = default;

    /**
     * @brief 無向辺の追加
     * 
     * @param v 辺が結ぶ頂点1
     * @param u 辺が結ぶ頂点2
     * @param cost 辺の重み(省略可、デフォルトは1)
     */
    void nd_add(int v, int u, T cost = 1){
        int edge_idx = edges.size();
        int from_idx = vertex[v].size();
        int to_idx = vertex[u].size();
        vertex[v].push_back(Edge<T>(v, u, cost, edge_idx, from_idx, to_idx));
        vertex[u].push_back(Edge<T>(u, v, cost, edge_idx, to_idx, from_idx));
        edges.push_back(Edge<T>(v, u, cost, edge_idx));
    }

    /**
     * @brief 有向辺の追加
     * 
     * @param from 出次する頂点
     * @param to 入次する頂点
     * @param cost 辺の重み(省略可、デフォルトは1)
     */
    void d_add(int from, int to, T cost = 1){
        int edge_idx = edges.size();
        int from_idx = vertex[from].size();
        vertex[from].push_back(Edge<T>(from, to, cost, edge_idx, from_idx));
        edges.push_back(Edge<T>(from, to, cost, edge_idx, from_idx));
    }

    /**
     * @brief  逆辺を追加する。
     * @note   今のところの使用用途、最大流くらい…
     * @param  cost: 省略可、逆辺のコスト
     * @retval 辺集合における双方の辺のインデックスの対応関係
     */
    vector<int> add_reverse(T cost = 0){
        int E = edges.size();
        vector<int> ret(2 * E);
        for(int i = 0; i < E; ++i){
            auto e = edges[i];
            d_add(e.to, e.from, cost);
            int idx = e.vertex_idx;
            int ridx = edges[i + E].vertex_idx;
            e.vertex_ridx = ridx;
            edges[i + E].vertex_ridx = idx;
            vertex[e.from][e.vertex_idx].vertex_ridx = ridx;
            vertex[e.to][ridx].vertex_ridx = idx;
            ret[i] = i + E;
            ret[i + E] = i;
        }
        return ret;
    }
};